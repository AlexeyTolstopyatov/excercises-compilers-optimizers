; попробую переписать функцию с большим колличеством аргументов
; вместо компилятора.

; int regs (int a, int b, int c, int d, int e, int f ...) {
;     return a + b + c + d + e + f + g + h;
; }

section .text
    global __regs

    __regs(int):
        push ebp ; Запомнить предыдущее значение
        mov ebp, esp
        ; Все еще помню: EAX возвращает значение "__regs"
        ; Позднее в EAX должен быть результат операции
        mov eax, [ebp + 8]  ; *a
        mov ebx, [ebp + 12] ; *b
        mov ecx, [ebp + 16] ; *c
        mov edx, [ebp + 20] ; *d
        mov edi, [ebp + 24] ; *e
        mov esi, [ebp + 28] ; *f
        mov esp, [ebp + 36] ; *h. Я переживаю за то, что  при изменении EBP
        mov ebp, [ebp + 32] ; *g  вероятно не получится запомнить аргумент [g]
        ; [h] надо получить как-то из стэка. Указатель стэка занят, дистанция занята, все занято.
        ; Как выкручиваться?  

        ; от перемены мест параметров, сумма не изменится
        add ebp, esp
        add ebp, esi
        add ebp, edi
        add ebp, edx
        add ebp, edx
        add ebp, ecx
        add ebp, ebx
        ; Теперь наоборот, чтобы можно было запомнить результат
        add eax, ebp 

        ; Очистительные сооружения
        mov esp, ebp    ; Восстановить указатель стэка
        pop ebp         ; Вспомнить, чем было EBP до изменений
        ret

; Основная сложность задания в том, что 8 регистров
; скорее всего для x86 внутри ОС использовать
; не хорошо. Потому что многие из них имеют для ОС
; важное значение
;
; Для Unix подобных систем, вроде бы
; EBX хранит состояние выполнения операции/программы
; EAX хранит результат функции
